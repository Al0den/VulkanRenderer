\
# Plan for Implementing Textures in VulkanRenderer

## 1. Goal (Done)
Implement texture mapping for game objects, specifically allowing each block type to use a dedicated texture applied to all its faces. Textures will be loaded from the `textures/` directory.

## 2. Project Analysis & Assumptions (Done)
- The project uses Vulkan for rendering.
- `stb_image.h` is available in `third-party/` for image loading.
- `tinyobjloader.hpp` is available for model loading; models are assumed to support or be adaptable for texture coordinates (UVs).
- A `SimpleRenderSystem` is in place and will be modified to handle textured objects.
- Descriptor sets are used for shader resources.
- Shaders are written in GLSL and compiled to SPIR-V.

## 3. Implementation Phases

### Phase 1: Texture Representation and Loading (Done)
*   **1.1. Create `Texture` Class:**
    *   **Files:** `include/texture.hpp`, `src/texture.cpp`
    *   **Purpose:** Encapsulate Vulkan texture resources (`VkImage`, `VkImageView`, `VkSampler`, `VkDeviceMemory`) and loading logic.
    *   **Details:**
        *   Constructor: Takes `vkengine::Device&` and texture file path.
        *   Methods for creating Vulkan image, image view, and sampler.
        *   Method to load texture data from a file using `stb_image.h`.
        *   Handle image layout transitions (e.g., to `VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL`).
        *   Proper resource cleanup in the destructor.
*   **1.2. `stb_image` Integration:**
    *   In one `.cpp` file (e.g., `src/texture.cpp` or a new `src/stb_image_impl.cpp`), define `STB_IMAGE_IMPLEMENTATION` before including `stb_image.h`.

### Phase 2: Model and Vertex Data Update
*   **2.1. Update Vertex Structure:**
    *   **File:** `include/model.hpp` (or relevant header defining `Vertex`).
    *   **Change:** Add `glm::vec2 uv;` (or similar) to the `Vertex` struct.
*   **2.2. Update Vertex Input Description:**
    *   **File:** `src/model.cpp` (or `src/pipeline.cpp` where vertex input descriptions are defined).
    *   **Change:** Add `VkVertexInputAttributeDescription` for the `uv` attribute in `Model::getAttributeDescriptions()` (or equivalent). Ensure `Model::getBindingDescriptions()` is compatible.

### Phase 3: Shader Modifications
*   **3.1. Vertex Shader (`shaders/textured_shader.vert`):**
    *   Add an input for texture coordinates: `layout(location = N) in vec2 inTexCoord;` (where N is the next available location, likely 2 if pos and color are 0 and 1).
    *   Add an output to pass texture coordinates to the fragment shader: `layout(location = M) out vec2 fragTexCoord;` (M can be 0 or a new location).
    *   In `main()`, assign `fragTexCoord = inTexCoord;`.
*   **3.2. Fragment Shader (`shaders/textured_shader.frag`):**
    *   Add an input for texture coordinates from the vertex shader: `layout(location = M) in vec2 fragTexCoord;`.
    *   Add a uniform sampler for the texture: `layout(set = S, binding = B) uniform sampler2D texSampler;` (S will likely be a new descriptor set index, e.g., 1, if set 0 is for global uniforms. B will be the binding index within that set, e.g., 0 or 1).
    *   In `main()`, sample the texture: `outColor = texture(texSampler, fragTexCoord);`. (Optionally, multiply by vertex color or a base color factor if needed).
*   **3.3. Shader Compilation:**
    *   Ensure the build system (CMake) recompiles these shaders to SPIR-V.

### Phase 4: Descriptors and Pipeline Integration
*   **4.1. Update Descriptor Set Layout:**
    *   **Files:** `include/descriptors.hpp`, `src/descriptors.cpp`, `src/systems/simple_render_system.cpp`.
    *   **Change:**
        *   Define a new `VkDescriptorSetLayout` specifically for textures, or augment an existing per-object/material layout. This layout will include a binding for `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER`.
        *   The `vkengine::DescriptorSetLayout::Builder` (if used) will need to be updated.
*   **4.2. Update Pipeline Layout:**
    *   **File:** `src/systems/simple_render_system.cpp` (in `createPipelineLayout` method).
    *   **Change:** Include the new texture descriptor set layout when creating the `VkPipelineLayout`. The `pSetLayouts` array and `setLayoutCount` in `VkPipelineLayoutCreateInfo` will need to be adjusted.
*   **4.3. Update Descriptor Pool:**
    *   **File:** `include/descriptors.hpp` or `src/descriptors.cpp`.
    *   **Change:** Ensure the `VkDescriptorPool` is created with enough capacity for `VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER` descriptors.
*   **4.4. Descriptor Set Allocation and Updates:**
    *   **Files:** `src/systems/simple_render_system.cpp` or `src/renderer.cpp`.
    *   **Change:**
        *   For each textured object (or material), allocate a `VkDescriptorSet` using the texture descriptor set layout.
        *   Update this descriptor set with the `VkDescriptorImageInfo` (sampler, image view, layout) from the loaded `Texture` object.

### Phase 5: Game Object and Rendering Logic Update
*   **5.1. `GameObject` Texture Association:**
    *   **File:** `include/game_object.hpp`.
    *   **Change:** Add a member to `vkengine::GameObject` to store texture information, e.g., `std::string textureName;` or `std::shared_ptr<vkengine::Texture> texture;`. This will be used to identify which texture to load/use.
*   **5.2. Texture Management (Optional but Recommended):**
    *   **Files:** Consider a `TextureManager` class (`include/texture_manager.hpp`, `src/texture_manager.cpp`) or integrate into `App` or `Renderer`.
    *   **Purpose:** To load, cache, and provide access to `Texture` objects by name/path, avoiding redundant loads.
    *   `std::unordered_map<std::string, std::shared_ptr<vkengine::Texture>> textureCache;`
*   **5.3. Update `SimpleRenderSystem::renderGameObjects()`:**
    *   **File:** `src/systems/simple_render_system.cpp`.
    *   **Change:**
        *   For each `GameObject`:
            *   Determine its texture (e.g., based on `textureName` or block type).
            *   Load the texture using the `TextureManager` (if it exists) or directly create a `Texture` object.
            *   Retrieve/create and bind the `VkDescriptorSet` for this texture before drawing the object: `vkCmdBindDescriptorSets(..., pipelineLayout, 1, 1, &textureDescriptorSet, ...)` (adjust set index).

### Phase 6: Texture Asset Convention and Loading Logic
*   **6.1. Define Texture Naming/Path Convention:**
    *   Establish a rule for how block types map to texture files.
    *   Example: A block type "stone" might look for `textures/stone/stone.png` or `textures/stone/stone_1.png`.
    *   The user request: "for every block type to try and find its relevant texture in assets/, with the texture being identical for every face of the block."
*   **6.2. Implement Texture Loading based on Convention:**
    *   Logic (likely in `TextureManager` or where `GameObjects` are initialized) to resolve the texture path based on the block type or `GameObject::textureName`.
    *   Handle cases where a texture might not be found (e.g., use a default placeholder texture like `textures/checker.png`).

### Phase 7: Build System Configuration
*   **7.1. Update `CMakeLists.txt`:**
    *   Add new source files (`texture.cpp`, `texture_manager.cpp` if created) to the compilation targets.
    *   Ensure `third-party/` is in the include directories for `stb_image.h`.
    *   Ensure shader files are correctly processed (e.g., recompiled if changed).

## 4. Testing and Validation
-   Render a scene with multiple game objects/blocks, each using a distinct texture.
-   Verify that textures are correctly applied to all faces of the blocks.
-   Check for any Vulkan validation layer errors or warnings.
-   Test with different texture image files (e.g., PNG, JPG if supported).

## 5. Future Considerations (Optional)
-   Mipmapping for better texture quality at different distances.
-   Texture arrays or atlases for performance if many small textures are used.
-   Support for different texture filtering and addressing modes.
-   Materials system that combines textures with other properties (e.g., shininess, normal maps).

This plan provides a structured approach to implementing textures. Each phase builds upon the previous one, starting from basic texture representation to full integration into the rendering pipeline.
